// Package graph provides a typed multigraph for systemd unit dependencies.
package graph

import (
	"sort"
	"sync"

	"github.com/supabase/sdaudit/pkg/types"
	"gonum.org/v1/gonum/graph"
	"gonum.org/v1/gonum/graph/multi"
)

// EdgeType represents the semantic meaning of a dependency relationship.
type EdgeType int

const (
	// Requirement edges - affect start/stop behavior
	EdgeRequires  EdgeType = iota // Hard dependency, failure propagates
	EdgeWants                     // Soft dependency, failure ignored
	EdgeBindsTo                   // Like Requires + stop propagates
	EdgeRequisite                 // Must already be active

	// Ordering edges - affect start/stop order only
	EdgeAfter  // Start after target
	EdgeBefore // Start before target

	// Negative edges - mutual exclusion
	EdgeConflicts // Cannot run together

	// Propagation edges - reload/stop propagation
	EdgePartOf               // Stop propagates (not start failure)
	EdgePropagatesReloadTo   // Reload triggers reload
	EdgeReloadPropagatedFrom // Receives reload propagation

	// Trigger edges
	EdgeTriggeredBy // Activated by another unit (e.g., socket activation)
)

// String returns the string representation of an edge type.
func (e EdgeType) String() string {
	switch e {
	case EdgeRequires:
		return "Requires"
	case EdgeWants:
		return "Wants"
	case EdgeBindsTo:
		return "BindsTo"
	case EdgeRequisite:
		return "Requisite"
	case EdgeAfter:
		return "After"
	case EdgeBefore:
		return "Before"
	case EdgeConflicts:
		return "Conflicts"
	case EdgePartOf:
		return "PartOf"
	case EdgePropagatesReloadTo:
		return "PropagatesReloadTo"
	case EdgeReloadPropagatedFrom:
		return "ReloadPropagatedFrom"
	case EdgeTriggeredBy:
		return "TriggeredBy"
	default:
		return "Unknown"
	}
}

// DirectiveToEdgeType maps systemd directive names to edge types.
var DirectiveToEdgeType = map[string]EdgeType{
	"Requires":             EdgeRequires,
	"Wants":                EdgeWants,
	"BindsTo":              EdgeBindsTo,
	"Requisite":            EdgeRequisite,
	"After":                EdgeAfter,
	"Before":               EdgeBefore,
	"Conflicts":            EdgeConflicts,
	"PartOf":               EdgePartOf,
	"PropagatesReloadTo":   EdgePropagatesReloadTo,
	"ReloadPropagatedFrom": EdgeReloadPropagatedFrom,
	"TriggeredBy":          EdgeTriggeredBy,
}

// IsRequirementEdge returns true if the edge type represents a requirement dependency.
func (e EdgeType) IsRequirementEdge() bool {
	return e == EdgeRequires || e == EdgeWants || e == EdgeBindsTo || e == EdgeRequisite
}

// IsOrderingEdge returns true if the edge type represents an ordering constraint.
func (e EdgeType) IsOrderingEdge() bool {
	return e == EdgeAfter || e == EdgeBefore
}

// PropagatesStartFailure returns true if start failure propagates through this edge.
func (e EdgeType) PropagatesStartFailure() bool {
	return e == EdgeRequires || e == EdgeRequisite || e == EdgeBindsTo
}

// PropagatesStop returns true if stop propagates through this edge.
func (e EdgeType) PropagatesStop() bool {
	return e == EdgeBindsTo || e == EdgePartOf
}

// Edge represents a typed relationship between units.
type Edge struct {
	From     string   // Source unit name
	To       string   // Target unit name
	Type     EdgeType // Relationship type
	File     string   // Which file defined this
	Line     int      // Line number in file
	Implicit bool     // Generated by systemd (e.g., default deps)
}

// unitNode implements gonum's graph.Node interface.
type unitNode struct {
	id   int64
	name string
}

func (n unitNode) ID() int64 { return n.id }

// unitEdge implements gonum's graph.Line interface for multigraph.
type unitEdge struct {
	id   int64
	from graph.Node
	to   graph.Node
}

func (e unitEdge) ID() int64        { return e.id }
func (e unitEdge) From() graph.Node { return e.from }
func (e unitEdge) To() graph.Node   { return e.to }
func (e unitEdge) ReversedLine() graph.Line {
	return unitEdge{id: e.id, from: e.to, to: e.from}
}

// Graph is a typed multigraph of unit dependencies.
type Graph struct {
	mu sync.RWMutex

	// Underlying gonum graph for algorithms
	g *multi.DirectedGraph

	// Our data
	units    map[string]*types.UnitFile // unit name -> parsed unit
	nodeIDs  map[string]int64           // unit name -> node ID
	nodes    map[int64]string           // node ID -> unit name
	edges    map[int64]Edge             // edge ID -> our rich Edge type
	allEdges []Edge                     // all edges in insertion order

	// Indexes for fast lookup
	outgoing map[string][]Edge // unit -> edges from unit
	incoming map[string][]Edge // unit -> edges to unit

	nextNodeID int64
	nextEdgeID int64
}

// New creates a new empty Graph.
func New() *Graph {
	return &Graph{
		g:        multi.NewDirectedGraph(),
		units:    make(map[string]*types.UnitFile),
		nodeIDs:  make(map[string]int64),
		nodes:    make(map[int64]string),
		edges:    make(map[int64]Edge),
		allEdges: make([]Edge, 0),
		outgoing: make(map[string][]Edge),
		incoming: make(map[string][]Edge),
	}
}

// AddUnit adds a unit to the graph.
func (g *Graph) AddUnit(unit *types.UnitFile) {
	g.mu.Lock()
	defer g.mu.Unlock()

	if _, exists := g.units[unit.Name]; exists {
		return
	}

	g.units[unit.Name] = unit
	id := g.nextNodeID
	g.nextNodeID++
	g.nodeIDs[unit.Name] = id
	g.nodes[id] = unit.Name
	g.g.AddNode(unitNode{id: id, name: unit.Name})
}

// AddEdge adds a typed edge between two units.
func (g *Graph) AddEdge(edge Edge) {
	g.mu.Lock()
	defer g.mu.Unlock()

	// Ensure both nodes exist (create placeholder if needed for dangling refs)
	if _, exists := g.nodeIDs[edge.From]; !exists {
		id := g.nextNodeID
		g.nextNodeID++
		g.nodeIDs[edge.From] = id
		g.nodes[id] = edge.From
		g.g.AddNode(unitNode{id: id, name: edge.From})
	}
	if _, exists := g.nodeIDs[edge.To]; !exists {
		id := g.nextNodeID
		g.nextNodeID++
		g.nodeIDs[edge.To] = id
		g.nodes[id] = edge.To
		g.g.AddNode(unitNode{id: id, name: edge.To})
	}

	// Add edge to gonum graph
	fromNode := g.g.Node(g.nodeIDs[edge.From])
	toNode := g.g.Node(g.nodeIDs[edge.To])
	edgeID := g.nextEdgeID
	g.nextEdgeID++
	g.g.SetLine(unitEdge{id: edgeID, from: fromNode, to: toNode})

	// Store our rich edge data
	g.edges[edgeID] = edge
	g.allEdges = append(g.allEdges, edge)

	// Update indexes
	g.outgoing[edge.From] = append(g.outgoing[edge.From], edge)
	g.incoming[edge.To] = append(g.incoming[edge.To], edge)
}

// Units returns all units in the graph (sorted by name for determinism).
func (g *Graph) Units() []*types.UnitFile {
	g.mu.RLock()
	defer g.mu.RUnlock()

	names := make([]string, 0, len(g.units))
	for name := range g.units {
		names = append(names, name)
	}
	sort.Strings(names)

	units := make([]*types.UnitFile, 0, len(names))
	for _, name := range names {
		units = append(units, g.units[name])
	}
	return units
}

// Unit returns a unit by name, or nil if not found.
func (g *Graph) Unit(name string) *types.UnitFile {
	g.mu.RLock()
	defer g.mu.RUnlock()
	return g.units[name]
}

// HasUnit returns true if the unit exists in the graph.
func (g *Graph) HasUnit(name string) bool {
	g.mu.RLock()
	defer g.mu.RUnlock()
	_, exists := g.units[name]
	return exists
}

// NodeNames returns all node names (including placeholders for dangling refs).
func (g *Graph) NodeNames() []string {
	g.mu.RLock()
	defer g.mu.RUnlock()

	names := make([]string, 0, len(g.nodeIDs))
	for name := range g.nodeIDs {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

// Edges returns all edges in the graph.
func (g *Graph) Edges() []Edge {
	g.mu.RLock()
	defer g.mu.RUnlock()

	edges := make([]Edge, len(g.allEdges))
	copy(edges, g.allEdges)
	return edges
}

// EdgesFrom returns all edges originating from a unit.
func (g *Graph) EdgesFrom(unit string) []Edge {
	g.mu.RLock()
	defer g.mu.RUnlock()

	edges := make([]Edge, len(g.outgoing[unit]))
	copy(edges, g.outgoing[unit])
	return edges
}

// EdgesTo returns all edges pointing to a unit.
func (g *Graph) EdgesTo(unit string) []Edge {
	g.mu.RLock()
	defer g.mu.RUnlock()

	edges := make([]Edge, len(g.incoming[unit]))
	copy(edges, g.incoming[unit])
	return edges
}

// EdgesOfType returns all edges of a specific type.
func (g *Graph) EdgesOfType(edgeType EdgeType) []Edge {
	g.mu.RLock()
	defer g.mu.RUnlock()

	var edges []Edge
	for _, e := range g.allEdges {
		if e.Type == edgeType {
			edges = append(edges, e)
		}
	}
	return edges
}

// GoNumGraph returns the underlying gonum graph for use with gonum algorithms.
func (g *Graph) GoNumGraph() *multi.DirectedGraph {
	return g.g
}

// NodeID returns the gonum node ID for a unit name.
func (g *Graph) NodeID(name string) (int64, bool) {
	g.mu.RLock()
	defer g.mu.RUnlock()
	id, ok := g.nodeIDs[name]
	return id, ok
}

// NodeName returns the unit name for a gonum node ID.
func (g *Graph) NodeName(id int64) (string, bool) {
	g.mu.RLock()
	defer g.mu.RUnlock()
	name, ok := g.nodes[id]
	return name, ok
}

// EdgeByID returns the edge data for a gonum edge ID.
func (g *Graph) EdgeByID(id int64) (Edge, bool) {
	g.mu.RLock()
	defer g.mu.RUnlock()
	edge, ok := g.edges[id]
	return edge, ok
}
